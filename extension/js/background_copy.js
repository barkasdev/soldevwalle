// A static import is required in b/g scripts because they are executed in their own env
// not connected to the content scripts where wasm is loaded automatically
import initWasmModule, {init_wasm, report_state} from './wasm/wasm_mod.js';

// importScripts('wasm/snippets/sqlite-wasm-rs-77a2229985ea0c4a/src/jswasm/sqlite3.js');
// import('wasm/snippets/sqlite-wasm-rs-77a2229985ea0c4a/src/jswasm/sqlite3.js')

console.log("Background script started");
// console.log(await chrome.permissions.getAll());

// import sqlite3InitModule from '@sqlite.org/sqlite-wasm';

// const supportsOpfs = typeof navigator.storage?.getDirectory === 'function';
// if (supportsOpfs) {
//     const directoryHandle = await navigator.storage.getDirectory();
//     console.log("OPFS available:", directoryHandle);
// } else {
//     console.error("OPFS not supported. Falling back to alternative storage.");
// }



// a temp flag to stop multiple fetches
let fetching = false;

// run the wasm initializer before calling wasm methods
// the initializer is generated by wasm_pack
(async () => {
    await initWasmModule();
    init_wasm("test-password"); // this call logs a hello message from WASM for demo purposes
    report_state("wasm initialized");
})();

// A placeholder for OnSuccess in .then
function onSuccess(message) {
    // console.log(`Send OK: ${JSON.stringify(message)}`);
}

// A placeholder for OnError in .then
function onError(error) {
    // console.error(`Promise error: ${error}`);
}

// A placeholder for OnError in .then
function onErrorWithLog(error) {
    console.error(`Promise error: ${error}`);
}

// Popup button handler
// Fetches the data from Spotify using the creds extracted earlier
chrome.runtime.onMessage.addListener(async (request, sender, sendResponse) => {
    console.log(`Popup message received: ${JSON.stringify(request)}, ${JSON.stringify(sender)}`);

    // only one wasm should be running at a time
    // TODO: disable the button
    if (fetching) {
        chrome.runtime.sendMessage("Already running. Restart the browser if stuck on this message.").then(onSuccess, onError);
        return;
    }

    // call the WASM code
    if (!fetching) {

        // indicate an active WASM process 
        fetching = true;

        toggleToolbarBadge();


        // call WASM
        report_state(JSON.stringify(request))
            .catch((e) => {
                console.error(e);
                chrome.runtime.sendMessage(JSON.stringify(e)).then(onSuccess, onError);
            })
            .finally(() => {
                // reset WASM, log to inactive and drop toolbar icon badge
                fetching = false;
                // restore the toolbar badge that signals to the popup that WASM is no longer running
                toggleToolbarBadge();
            })
    }
});

/// Sets the badge as per fetching var and notifies the popup about the status change
/// When the popup window is loaded, it checks if the badge is set and presumes that the WASM script is running
function toggleToolbarBadge() {
    chrome.action.setBadgeText(
        {text: (fetching) ? "..." : ""}
    ).then(onSuccess, onErrorWithLog)
    chrome.runtime.sendMessage(fetching).then(onSuccess, onError);
}


onmessage = e => {
    const message = e.data
    console.log(`background.js: ${message}`);
}



